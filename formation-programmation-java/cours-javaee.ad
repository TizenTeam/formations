= Java EE
:author: Arnaud Tournier
:email: ltearno@gmail.com
:backend: revealjs
:deckjs_theme: neon
:revealjs_theme: beige
:revealjs_history: true
:imagesdir: images-javaee
:source-highlighter: highlightjs
////
:revealjs_transition: zoom
Java EE
2016 - LTE Consulting
:source-highlighter: pygments
////

== Java EE

**Définition**, serveur d'application.

Plateforme Java Enterprise Edition, sur ensemble de la plateforme standard.

Facilite le développement et le déploiement d'applications web distribuées exécutées au sein des serveurs d'application.

=== Quelques implémentations

JavaEE est une norme, il faut choisir l'implémentation : Tomcat, JBoss, Glassfish, ...

Application divisées en couches, souvent trois (presentation, business, data).

En pratique on a des pages htmls + servlets + jsp en frontal et ejb dans les couches internes (métier, processus et données).

=== Structure d'une application Java EE

```
/
|- fichiers publiques **.html**, **.jsp**, **.css**, **.js**, ...
|- WEB-INF/ (_cachés à l'utilisateur_)
  |- classes
    |- fichiers **.class**
  |- lib
    |- fichiers **.jar**
  |- **web.xml** : C'est un fichier de configuration de l'application
```

== Développement avec Eclipse

Installation de Tomcat, déclaration dans Eclipse, création d'un projet Dynamic Web Application et du serveur dans Eclipse.

Démarrage d'une application avec un fichier index.html dedans.

== HTTP

Rappels HTTP, requête, méthode (GET, POST), headers, cookies.

== Servlet

Une classe qui traite les requêtes HTTP.

=== Mise en place

Une servlet est une simple classe Java...

- Elle hérite de `javax.servlet.http.HttpServlet`,
- On implémente une des méthodes choisies `doGet`, `doPost` (l'implémentation par défaut renvoie une page 404).
- On indique au serveur quels sont l(es) URL(s) traitées par la servlet. Ceci se fait dans le fichier `web.xml` ou par annotation.

=== HttpServletRequest

Représente la requête

Paramètres, cookies

Attributs...

=== HttpServletResponse

Représente la réponse.

=== Cycle de vie

Le cycle de vie est géré par le serveur d'application (_d'où son nom_).

Celui-ci _crée_ et _détruit_ des instances de la classe.

=== Exemple

[source]
----
class MaServlet extends HttpServlet
{
	protected void doGet( HttpServletRequest r, HttpServletResponse re )
	{
		re.setContentType( "text/html; charset=utf8" );
		re.getWriter().print( "Hello world !" );
	}
}
----


== JSP

=== Définition

L'écriture de la vue (en HTML) est _pénible_ dans un fichier Java. Les `JSP` permet au contraire d'écrire en HTML et d'injecter du Java.

=== Fonctionnement

Vous écrivez des fichiers `.jsp`.

Ces fichiers sont compilés vers des servlets Java.

La servlet est accessible à l'URL correspondant au nom du fichier JSP (sauf quand il est dans `WEB-INF`).

Les variables `request`, `response`, ... sont accessibles.

=== Exercice

Faire une page de login.

NOTE: Pour l'UTF-8, mettre :

[source]
----
<%@ page pageEncoding="UTF-8" %>
----

Executer du code : `<% ... %>`

Faire un echo : `<%= ... %>`

Commentaires : `<%-- ... --%>`

Directive : `<%@ page import="package.class"%>`, ...

=== Formulaires

L'envoi de données au moment de la requête se fait grâce aux formulaires HTML.

Les valeurs des formulaires sont récupérées grâce à la méthode `getParameter( String name )` de la classe `HttpServletRequest`.

=== Les JSTL

Il est possible d'enrichir le _vocabulaire_ des balises utilisables dans un ficher JSP.

Cette fonctionnalité est fournie par les _tag lib_ JSTL.

https://openclassrooms.com/courses/creez-votre-application-web-avec-java-ee/objectifs-et-configuration[OpenClassRooms]

=== Importation d'une tag lib

_Au préalable, il faut avoir le jar `jstl-1.2.jar` dans le projet_.

Importation dans une JSP :

[source]
----
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
----

Ceci définit le _namespace_ XML `c`.

=== JSTL Exemple 1

Ceci est l'équivalent de la directive `<%@ include file="..." %>` :

[source]
----
<jsp:include page="<%= jspPageName %>" />
----

=== JSTL Exemple 2

Nous souhaitons réécrire le code suivant :

[source,language="jsp"]
----
<ul>
<% for( int i = 0; i <= 7; i++ ) { %>
	<li><%= i %></li>
<% } %>
</ul>
----

=== JSTL Exemple 2

Voici l'équivalent avec la JSTL :

[source,language="jsp"]
----
<ul>
<c:forEach var="i" begin="0" end="7" step="1"> <1>
  <li>${i}</li> <2>
</c:forEach>
</ul>
----
<1> le noeud `forEach` crée une variable EL `i`.
<2> la variable `i` est utilisée dans des expressions EL.

=== JSTL Exemple 3

Code sans JSTL :

[source,language="jsp"]
----
<ul>
<% for( User user : users ) { %>
	<li>
		<%= user.getName() %>
		<%= user.getAge() %>
	</li>
<% } %>
</ul>
----

=== JSTL Exemple 4

Equivalent JSTL :

[source,language="jsp"]
----
<ul>
<c:forEach var="user" items="${users}"> <1>
  <li>${user.name} ${user.age}</li> <2>
</c:forEach>
</ul>
----
<1> **ATTENTION** la variable `users` doit être disponible
<2> Les getters `getName()` et `getAge()` suivent la convention java bean.

=== Expression Language

https://openclassrooms.com/courses/creez-votre-application-web-avec-java-ee/la-technologie-jsp-2-2[OpenClassRooms].

Quelques éléments du langage :

- `${ expression }` : _expression_ va être interprêtée...
- `${ true && true }` : ...
- `${ 10 mod 4 }` : ...
- `${ requestScope['nom'] }` : request.getAttribute( "nom" )
- `${ sessionScope['nom'] }` : session.getAttribute( "nom" )
- `${ param['id'] }` : request.getParameter( "id" )

=== EL exemple

[source]
----
<% 
List<String> legumes = new ArrayList<String>();
legumes.add( ... );
request.setAttribute( "legumes" , legumes );
%>

${ legumes.get(1) }
${ legumes[1] }
${ legumes["1"] }
----

=== Variables pour JSTL

Dans une expression EL, on peut utiliser :

- les variables issues des boucles `<c:foreach>`,
- les variables passées depuis java :

[source]
----
pageContext.setAttribute( "users", users );
----

=== MVC etc

On va mettre en place un _pattern_ qui va nous permettre de séparer :

- données et traitement (en Java pur),
- production de documents (en HTML presque pur).

_Ceci est réalisé en faisant transiter des informations entre une
servlet java et une vue JSP._

=== Délégation 1

Délégation à partir d'une servlet :

[source]
----
void doGet( HttpServletRequest request, HttpServletResponse response )
{
	this.getServletContext()
		.getRequestDispatcher( "/WEB-INF/test.jsp" )
		.forward( request, response );
}
----

=== Délégation 2

Transmission d'information. Dans la servlet :

[source,language="java"]
----
request.setAttribute( "test", message );
----

Dans la JSP, on écrira :

[source,language="jsp"]
----
<% String attribut = (String) request.getAttribute("test"); %>

ou en EL : ${test}
----



=== Scope 1

Lorsqu'on développe une application, les objets qui représentent les données peuvent avoir différentes portées et durée de vie :

- La durée de l'application (liste des users, ...),
- Propre à connexion d'un utilisateur (login, panier),
- Le temps d'une requête (paramètre HTTP),
- Certaines variables (JSTL) ne vivent que pendant le rendu d'une page.

=== Scope 2

Java EE définit quatre _scopes_ (portées ou cycles de vie) pour les objets :

`application`, `session`, `request` et `page`.

Ceux-ci sont implémentés grâce aux attributs de requête, de session, et de contexte applicatif.

=== Scope

|===
|Portée | Servlet | EL

|*application*
|`getServletContext()`
|`applicationScope[]`

|*session*
|`request.getSession()`
|`sessionScope[]`

|*request*
|`request`
|`requestScope[]`

|*page*
|-
|`pageScope[]`
|===

=== Filtres

Il est possible d'appliquer un traitement sur les requêtes en amont de celui-ci effectué par les Servlets. Ceci permet d'exécuter un traitement générique indépendamment de l'url demandée par l'utilisateur.

Le filtre peut alors soit laisser le traitement de la requête se poursuivre, soit effectuer le traitement de son choix, ou même émettre une réponse HTTP à la place de la servlet qui devait être déclenchée pour traiter la requête.

Ceci est particulièrement adapté aux problématiques transverses comme la sécurité.

=== Filtres utilisation

- On déclare une classe qui implémente l'interface `javax.servlet.Filter`.
- On déclare les urls sur lesquelles le filtre est actif avec l'annotation `@WebFilter`

=== Exemple

[code,language=java]
----
@WebFilter( "/*" )
public class SecurityFilter implements Filter
{
	public void init( FilterConfig fConfig ) throws ServletException
	{
		// initialisation si besoin
	}

	public void doFilter( ServletRequest request, ServletResponse response,
			FilterChain chain )
			throws IOException, ServletException
	{
		// traitement du filtre

		// passage de la requête au filtre ou servlet suivant
		if( condition )
			chain.doFilter( request, response );
		else
			response.sendRedirect( ... ); // par exemple
	}

	public void destroy()
	{
		// nettoyage des resources si besoin
	}
}
----

=== Sécuriser une appli avec des filtres

Une utilisation classique des filtres est la sécurisation d'une application.

- On ne va permettre l'accès aux resources qu'à la condition que l'utilisateur soit connecté.
- On considère que certaines URLs sont à protéger, et certaines pas.
- Le filtre vérifie le droit d'accès à la resource demandée et en fonction poursuit le traitement de la requête ou pas.

=== Filtre - Avantages

Un filtre permet d'effectuer un traitement en amont des traitements métiers spécifiques des Servlet.

C'est donc un bon moyen de s'assurer qu'un traitement sera fait quoiqu'il arrive (ajout de servlet, modification du code, etc...).


== JavaBean

Une convention pour exprimer la notion de _propriété_. En écriture et/ou lecture.

Exemple, la propriété `Longueur` :

[source,language="java"]
----
int getLongueur() { ... }
void setLongueur( int valeur ) { ... }
----

Il peut y avoir une notion d'abonnement (pattern _Observer_).


=== Les opérations CRUD

En exercice, implémenter sur un type de données :

- l'affichage (**D**isplay),
- la création de nouveaux éléments (**C**reate),
- la suppression d'éléments (**R**emove),
- la modification d'éléments (**U**pdate).


== JSF

=== Introduction

C'est un framework MVC pour simplifier l'écriture d'interface graphiques Web.

Fonctionne au dessus de l'api Servlet. Stable et utilisable depuis la version 2.0 en 2009.

=== FacesServlet

Une seule servlet prend en charge toutes les requêtes et maintient l'état de la vue de _chaque_ client.

`javax.faces.webapp.FacesServlet`

=== Facelet

La programmation des vues repose sur _Facelet_, description XML des composants de la vue.

Fichiers `*.xhtml`

=== Controlleur

La programmation des actions (_controlleur_) s'écrit dans des _Java Beans_.

`@ManagedBean`, `@RequestScoped`, `@ViewScoped`, `@SessionScoped`, `@ApplicationScoped`, `@CustomScope` et `@NoneScoped`...

=== Modèle

Les données attachées aux échanges HTTP sont stockées dans des _Java Beans_ attachés aux différents scopes.

=== Avantage

Facilite la gestion conversationnelle grâce au modèle par composant.

Gère par ex. état des vues, maj des modèles, invocation des actions métiers, génération de la réponse, évènements, validation, internationnalisation...

=== Contrepartie

On ne maîtrise pas vraiment le HTML généré car la génération de celui-ci est encapsulée dans le code des composants.

=== Structure d'une application JSF

- Vue : Facelet (un fichier *xhtml*),
- Modèle : entité JPA ou JavaBean,
- Controlleur : des `@ManagedBean`s

Configuration en plus de `web.xml` dans `faces-config.xml`.

=== Les fichiers Facelet

Ce ne sont que des fichiers XHTML (HTML conforme au XML). On utilise les extensions : **.jsf** ou **.xhtml** ou **.faces**.

Références des balises JSF : http://docs.oracle.com/javaee/6/javaserverfaces/2.1/docs/vdldocs/facelets/[ici], http://www.jsftoolbox.com/documentation/help/12-TagReference/index.jsf[ici] et sur http://stackoverflow.com/tags/jsf/info[stack overflow].

=== Exemple

[source,language="xml"]
----
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" 
	   xmlns:f="http://java.sun.com/jsf/core" 
	   xmlns:h="http://java.sun.com/jsf/html"> 
	<h:head>
		<title>Bienvenue</title>
		<h:outputStylesheet library="default" name="cartes.css"></h:outputStylesheet>
	</h:head>
	<h:body>
		<h:form>
			<h:inputText value="#{utilisateur.nom}" />
			<h:commandButton value="Valider" action="bienvenue" />
		</h:form>
	</h:body>
</html>
----

=== Expression Language pour JSF

L'évolution technique d'expression language fait que pour JSF, on utilise la syntaxe du type :

		#{inscrireBean.utilisateur.motDePasse}
		
On voit donc que `$` est remplacé par `#`. Ceci correspond au fait que l'expression language pour JSF permet d'appeler des *setters* sur les java beans, ce qui n'est pas permis avec `$`.

Depuis Java EE 6, expression language a été unifié et il est maintenant possible d'utiliser `#` dans les JSP.

=== Les 6 étapes du traitement d'une requête (1/2)

- **Restauration de la vue** : si c'est un premier accès JSP crée une donnée de vue (l'arbre des composants) dans `FacesContext`. Sinon JSF recharge simplement les données de la vue.
- **Application des paramètres** de la requête : JSF fait automatiquement le lien entre les paramètres présents dans la requête et les champs du modèle à modifier.
- **Validation des données** : si la validation échoue, on passe directement à la dernière étape.

=== Les 6 étapes du traitement d'une requête (2/2)

- **Mise à jour du modèle** : si la validation s'est bien déroulée, cette étape consiste à mettre à jour les données du modèle avec les données validées.
- **Appel au code métier** de l'application : les actions déclarées dans les formulaires sont exécutées, sous la forme d'appels aux méthodes des Beans.
- **Rendu de la réponse** : l'arbre des composants est appelé afin de générer le HTML résultat. Il est mémorisé pour la prochaine _Restauration de vue_.

=== Configuration

Dans `web.xml` on ajoute :

[source,language="xml"]
----
<context-param>
	<!-- autres noms possibles : STATE_SAVING_METHOD, INTERPRET_EMPTY_STRING_SUBMITTED_VALUES_AS_NULL ... -->
	<param-name>javax.faces.PROJECT_STAGE</param-name>
	<param-value>Development</param-value>
</context-param>

<servlet>
	<servlet-name>FacesServlet</servlet-name>
	<servlet-class>javax.faces.webapp.FacesServlet</servlet-class>
	<load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
	<servlet-name>FacesServlet</servlet-name>
	<url-pattern>*.xhtml</url-pattern>
</servlet-mapping>
----
		
=== Tutoriel

https://openclassrooms.com/courses/creez-votre-application-web-avec-java-ee/premiers-pas-avec-jsf

=== Gestion de formulaires

https://openclassrooms.com/courses/creez-votre-application-web-avec-java-ee/la-gestion-d-un-formulaire-avec-jsf

== SGBD-R

=== Systèmes de gestion de base de données relationnelles

Un outil pour :

- **structurer**,
- **stocker**,
- **interroger**,
- et garantir l'**intégrité** des données.

=== Service

Le SGBD est un processus actif sur une machine. Il ouvre des ports de communication.

Et les applications s'y connectent.

=== Table

Nous stockons les **enregistrements** dans des **tables** possédant une ou plusieurs *colonnes* :

[cols=2, options="header"]
|===
|Nom
|Prénom

|Tournier
|Arnaud

|Dupont
|Jean

|Serres
|Mélanie

|Dupont
|Jean
|===

=== Clé

Les enregistrements sont repérés de façon sûre grâce aux **identifiants** aussi appelés **clés primaire (PK)**.

Chaque identifiant est **unique**.

[cols=3, options="header"]
|===
|ID
|Nom
|Prénom

|1
|Tournier
|Arnaud

|3
|Dupont
|Jean

|7
|Serres
|Mélanie

|4
|Dupont
|Jean
|===

=== Clé étrangère

Pour relier les enregistrements entre eux, on utilise les **clés étrangères** :

[cols=4, options="header"]
|===
|ID
|Entreprise_ID
|Nom
|Prénom

|1
|44
|Tournier
|Arnaud

|3
|5
|Dupont
|Jean

|4
|44
|Serres
|Mélanie
|===

=== DDL

Langage permettant de définir la structure des données dans la base de données.

[source,language="sql"]
----
CREATE TABLE IF NOT EXISTS `personne` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `nom` text COLLATE utf8_bin NOT NULL,
  `prenom` varchar(50) COLLATE utf8_bin NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin AUTO_INCREMENT=1;
----

=== SQL

Langage permettant d'interroger, de créer, supprimer et manipuler les données, en fonction de la structure définie.

Quelques exemples...

=== Insert

Insérer un enregistrement dans une table :

[source,language="sql"]
----
INSERT INTO `personne` (`nom`, `prenom`) VALUES ('Tournier', 'Arnaud');
----

Dans cette table, l'identifiant est généré automatiquement...

=== Update

Mise à jour d'un ou des enregistrements :

[source,language="sql"]
----
UPDATE `personne` SET `nom`="Toto", `prenom`="Titi" WHERE id=1;
----

=== Delete

[source,language="sql"]
----
DELETE FROM `personne` WHERE nom LIKE "To%";
----

=== Select

L'opération la plus utilisée : pour consulter la base de données

[source,language="sql"]
----
SELECT * FROM `personne` WHERE prenom LIKE "a%";
----

=== Jointure

Il est possible de _combiner_ des tables en faisant un select :

[source,language="sql"]
----
SELECT * FROM `personne` p LEFT JOIN `entreprise` e ON p.entreprise_id=e.id;

SELECT p.id, p.nom, e.nom, e.adresse FROM `personne` p LEFT JOIN `entreprise` e ON p.entreprise_id=e.id;
----

=== Transactions

On souhaite pouvoir exécuter une suite d'instruction de manière **atomique** et **cohérente** (voir les propriétés _ACID_).

[source,language="sql"]
----
START TRANSACTION;
COMMIT; // on valide ou...
ROLLBACK; // on annule
----

_Interblocage ?_

=== Bien plus...

Le langage SQL est extrêmement riche, nous avons à peine gratté la surface...

Voici un http://sql.sh/[cours et tutoriel] pour aller plus loin.

=== Quelques serveurs SQL

De nombreuses implémentations existent, avec parfois quelques variantes dans le _dialecte_ SQL : MySQL, MariaDB, Oracle, PostgreSQL, Microsoft SQL Server, SQLite, ...

=== Important !

- Un SGBD peut gérer plusieurs _bases de données_,
- Une base de données peut contenir plusieurs _tables_,
- Une table possède plusieurs _colonnes_.
- Les enregistrements sont repérés par leur _clé primaire_,
- On référence un enregistrement à partir d'un autre avec une _clé étrangère_.
- SQL garantit la cohérence des données avec les _transactions_.

== JDBC

=== Accès depuis un programme Java

L'accès le plus bas niveau avec Java se fait à travers le _driver JDBC_ adapté au serveur auquel on se connecte.

=== Charger le driver adapté

La classe doit être présente dans le _classpath_...

[source,language="java"]
----
try
{
	Class.forName( "com.mysql.jdbc.Driver" );
}
catch( ClassNotFoundException e )
{
	...
}
----

=== Se connecter au serveur SQL

Il faut connaître l'URL de connexion...

[source,language="java"]
----
try
{
	Connection conn = DriverManager.getConnection( "jdbc:mysql://localhost:3306/cartes", "root", "password" );
}
catch( SQLException e )
{
	...
}
----

=== Exécuter des requêtes

Exemple de `SELECT` :

[source,language="java"]
----
Statement statement = conn.createStatement();
ResultSet rs = statement.executeQuery( "SELECT id, nom, couleur from carte" ); <1>
while( rs.next() )
{
	String id = rs.getString( "id" );
	String nom = rs.getString( "nom" );
	String couleur = rs.getString( "couleur" );

	System.out.printf( "%s %s %s\n", id, nom, couleur );
}
----
<1> Il existe aussi `executeUpdate()` pour les statements SQL modifiant les données en base, et `execute()` pour le reste (voir la Javadoc)

=== Requête d'insertion

[source,language=java]
----
String sqlQuery = "INSERT INTO produits (`designation`) "
		+ "VALUES ('" + produit.getDesignation() + "')";

PreparedStatement statement = databaseConnection.prepareStatement( sqlQuery );
int nbEnregistrementInseres = statement.executeUpdate(); <1>
if( nbEnregistrementInseres == 0 )
	throw new RuntimeException( "Aucun enregistrement inséré" );

// Les clés de(s) enregistrement(s) insérés sont obtenus sous la forme d'un `ResultSet` :
ResultSet createdIds = statement.getGeneratedKeys();
if( createdIds.next() )
	produit.setReference( createdIds.getInt( 1 ) );
else
	throw new RuntimeException( "Aucun produit ajouté" );
----
<1> Ici on utilise `executeUpdate()`

=== Utilisation des paramètres

[source,language=java]
----
PreparedStatement updateSales = null;

String updateString =
        "update COFFEES set SALES = ? where COF_NAME = ?";

updateSales = con.prepareStatement(updateString);

updateSales.setInt(1, 42);
updateSales.setString(2, "Toto");

updateTotal.executeUpdate();

updateTotal.close();
----

Voir http://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html

=== Les transactions

Les instructions de transactions sont accessibles directement en Java :

[source,language="java"]
----
// on désactive l'auto-commit
conn.setAutoCommit( false );

// on joue la transaction...
Statement statement = conn.createStatement();
// ...

// on valide la transaction
conn.commit();
// on aurait pu l'annuler avec 'conn.rollback()'
----

=== Plus de JDBC

Pour aller plus loin avec JDBC, consulez la https://docs.oracle.com/javase/tutorial/jdbc/basics/[documentation officielle].

== ORM

L'écriture du code SQL et DDL est fastidieuse et répétitive. Les _ORM_s sont une sur-couche qui permettent un accès au SGBD plus conforme à la vision objet.

L'ORM prend en charge la communication avec le SGBD et fourni à l'application une _API_ de plus haut niveau.

=== JPA

- Java Persistence API,
- https://jcp.org/en/jsr/detail?id=317[JSR 317],
- _Entity manager_ et _Entités_,
- langage _JPQL_...
- package `javax.persistence`.

Lire la spécificaton http://download.oracle.com/otndocs/jcp/persistence-2_1-fr-eval-spec/index.html[ici].

=== Fournisseurs

Plusieurs implémentations : Hibernate, Toplink, DataNucleus, ...

=== @Entity

- Classe dont l'état est sauvegardé dans une _table_.
- Chaque instance correspond à un _enregistrement_.
- Les attributs correspondent aux colonnes.
- Les relations sont exprimées avec des annotations (ou xml).

=== @Id

Dénote l'attribut utilisé comme clé primaire.

On précise la stratégie de génération des identifiants.

=== Exemple

[source,language="java"]
----
@Entity
public class Utilisateur
{
	@Id
	@GeneratedValue( strategy = GenerationType.IDENTITY )
	private Integer id;

	@NotNull
	private String nom;
	
	// méthodes, getters, setters
}
----

=== @Column

Permet de changer entre autres le nom de la colonne choisi par défaut par JPA.

Attributs : `name`, `length`, `unique`, `nullable`, `insertable`, `updatable`, `precision`, `scale`, `columnDefinition`...

=== @Lob

L'annotation `@Lob` permet de préciser à JPA que la valeur de l'attribut sera à stocker sous forme binaire dans la table SQL elle-même.

=== Entity Manager

Une instance de la classe `EntityManager` fait le lien entre les données de la base et les objets _entités_.

Celle-ci est fournie par le serveur d'application, et est connectée directement à la base de donnée configurée dans le serveur.

Opérations : `persist`, `merge`, `remove`, `find`, `createQuery`...

Maintient l'assertion 1 enregistrement <=> 1 entité.

=== Persist

[source,language="java"]
----
public void add( Utilisateur utilisateur )
{
	em.persist( utilisateur );
}
----

Rend une entité gérée et persistante. Etat sauvegardé au prochain _flush_ / _commit_.

=== Merge

[source,language="java"]
----
public Utilisateur save( Utilisateur utilisateur )
{
	return em.merge( utilisateur );
}
----

Attache l'entité à l'entity manager courant. Recopie l'état de l'entité en paramètre dans l'état de l'entité _gérée_.

Retourne l'entité associée à l'entity manager courant.

=== Find

[source,language="java"]
----
public Utilisateur findById( int id )
{
	return em.find( Utilisateur.class, id );
}
----

L'entité retournée est _gérée_.

=== Remove

[source,language="java"]
----
public void delete( Utilisateur utilisateur )
{
	em.remove( utilisateur );
}
----

Rend une entité _supprimée_. Retirée de la BDD au prochain _commit_ / _flush_.

=== Refresh

[source,language="java"]
----
em.refresh( utilisateur );
----

Synchronise l'état de l'entité avec la base de données. Abandonne modifications en cours.

=== Detach

[source,language="java"]
----
em.detach( utilisateur );
----

Détache l'entité de l'entity manager. Les modifications faites dessus ne seront donc pas prises en compte au prochain commit.

=== JPQL

Langage inspiré par SQL qui est pensé avec le paradigme objet.

=== Create Query

[source,language="java"]
----
public Utilisateur findByLogin( String login, String motDePasse )
{
	Query query = em.createQuery( "from Utilisateur u where u.login=:login and u.motDePasse=:motDePasse" );
	
	query.setParameter( "login", login );
	query.setParameter( "motDePasse", motDePasse );

	Utilisateur u = (Utilisateur) query.getSingleResult();
	return u;
}
----

=== Create Query

[source,language="java"]
----
public List<Utilisateur> getUtilisateurs()
{
	Query query = em.createQuery( "from Utilisateur" );
	
	List<Utilisateur> result = (List<Utilisateur>) query.getResultList();
	
	return result;
}
----

=== Criteria API

Il y a aussi une http://docs.oracle.com/javaee/6/tutorial/doc/gjitv.html[API] pour éviter le _JPQL_ et construire les requêtes programmatiquement.

=== Requêtes nommées

=== Relations

JPA gère les relations entre enregistrements et donc entre entités.

http://docs.oracle.com/javaee/7/tutorial/persistence-intro001.htm#BNBQA[voir ce site]

Et l'excellent tuto de José http://blog.paumard.org/cours/jpa/chap03-entite-relation.html[ici]

=== Règles

- Les relations JPA ne sont possible qu'entres classes `@Entity`.
- Peuvent être _unidirectionnelles_ ou _bidirectionnelles_ (une source, une cible).
- Dans le cas des relations `1:1` et `n:p`, on peut choisir le côté source comme on le souhaite. Dans le cas des relations `1:p` et `n:1`, l'entité du côté `1` est l'entité cible.

=== @OneToOne

Exemple : `Maire` et `Commune`.

Unidirectionnel :

- dans `Commune`, un attribut de `Maire maire` est annoté avec `@OneToOne` (colonne `maire_id` dans la table `commune`, voir `@JoinColumn("name"=...)`).

Bidirectionnel :

- dans l'entité `Maire`, on peut ajouter `@OneToOne` avec son attribut `mappedBy` qui contient le nom de l'attribut utilisé dans la classe source.

=== @OneToMany et @ManyToOne

`@ManyToOne` est utilisée côté source et correspond à une clé étrangère vers l'entité cible.

On précise le champ de retour dans l'attribut `mappedBy` de l'annotation `@OneToMany` dans l'entité cible.

Côté `@OneToMany`, l'attribut Java est de type `Collection` (`List`, `Set`, ...).

=== @ManyToMany

Utilise et gère une _table de jointure_.

Les entités source et cible utilisent toutes les deux `@ManyToMany`.

L'entité cible valorise l'attribut `mappedBy` de l'annotation.

=== Utilisation standalone

Il est possible d'utiliser JPA indépendamment d'un serveur d'application Java EE.

=== Cascade

Le comportement cascade consiste à spécifier ce qui se passe pour une entité en relation d'une entité père (que cette relation soit monovaluée ou multivaluée), lorsque cette entité père subit une des opérations de persistence (DETACH, MERGE, PERSIST, REMOVE, REFRESH).

Utilisable dans les annotations `@OneToOne`, `@OneToMany` et `@ManyToMany`.

=== Orphan removal

Lorsqu'une entité n'est plus référencée par aucune autre on dit qu'elle est orpheline.

JPA permet de configurer le comportement à avoir lorsqu'une entité devient orpheline. Positionner `orphanRemoval=true` sur une relation `@OneToOne` ou `@OneToMany` activera l'effacement des entités orphelines.

=== Dans une application JavaEE

JPA est totalement intégré au fonctionnement d'une application Java EE.

Plusieurs éléments de configuration sont nécessaires...

=== Sources de données

Les _Data source_ sont configurées dans le serveur d'application. On y précise le _driver_, l'_url de connexion_ et les information d'_authentification_.

Chaque implémentation se configure différemment.

=== Fichier persistence

`META-INF/persistence.xml`

[source,language="xml"]
----
<?xml version="1.0" encoding="UTF-8"?>
<persistence version="2.0" xmlns="http://java.sun.com/xml/ns/persistence">
	<persistence-unit name="Cartes" transaction-type="JTA"> <1>
		<jta-data-source>CartesDS</jta-data-source>

		<properties>
			<property name="hibernate.hbm2ddl.auto" value="update" />
			<property name="hibernate.dialect" value="org.hibernate.dialect.MySQL5Dialect" />
		</properties>
	</persistence-unit>
</persistence>
----
<1> Type de transaction JTA

=== EJB

- **Composants** logiciels (métier) de base de Java EE.
- Naturellement **distribué**.
- Evoluent dans un milieu **transactionnel**.

=== Plusieurs types

- `@Local` ou `@Remote`,
- `@Stateful` ou `@Stateless`,
- EJB Message.
- Enregistré dans JNDI.

=== Création d'un EJB

Soit une interface (`@Remote` ou `@Local`) et une classe, soit depuis EJB 3 une seule classe :

[source,language="java"]
----
// un EJB de session sans état
@Stateless
public class MonEJB {
	// par exemple :
	@PostConstruct
	void onInit() {
	}
}
----

=== Injection de dépendances

Le serveur d'application peut injecter des composants en utilisant les annotations :

- `@EJB` : un autre EJB,
- `@Resource` : une resource JNDI (EntityManager, UserTransaction, SessionContext, ...),

=== Exemple

[source,language="java"]
----
@Stateless( mappedName = "MarinService" )
public class MarinServiceImpl implements MarinService {
	@Resource
	private UserTransaction transaction;

	@Resource( mappedName = "jdbc/CartesDS" )
	private DataSource dataSource;

	@PersistenceContext( unitName = "CartesDS" )
	private EntityManager em;

	// ...
}
----

=== Injection de l'unité de persistence

Au sein d'un _EJB_, on peut injecter une instance de l'`EntityManager` :

[source,language="java"]
----
@Stateless
public class ProduitDao
{
	@PersistenceContext( name = "SiteDeVente" )
	EntityManager em;
	
	// ...
	// utilisation de l'EntityManager
}
----

=== Injection d'un EJB dans une Servlet

Au sein d'une servlet, il est possible d'injecter une instance de l'EJB :

[source,language="java"]
----
@WebServlet( "/youpi" )
public class ProduitsServlet extends HttpServlet
{
	@EJB
	ProduitDao produitDao;

	protected void doGet()
	{
		// utilisation du DAO
	}
}
----

=== Injection d'un EJB dans un bean JSF

Au sein d'une servlet ou d'un _Managed Bean_, il est possible d'injecter une instance de l'EJB :

[source,language="java"]
----
@ManagedBean
@ViewScoped
public class ProduitsBean implements Serializable
{
	@EJB
	ProduitDao produitDao;

	// ...
	// utilisation du DAO
}
----

=== Gestion de la transaction

Les méthodes EJB s'exécutent dans un contexte _transactionnel_. Une transaction est (toujours) ouverte (automatiquement).

Le comportement est modifiable avec `@TransactionAttribute`.

Si une exception surgit hors de la méthode, la transaction est abandonnée (_rollback_).

=== Pattern DAO

DAO:: Data Access Object ayant la responsabilité de fournir les données.
C'est lui qui accède à l'`EntityManager`.

=== Architecture 3 tiers

C'est une architecture classque pour les applications d'entreprise.

- Présentation,
- Métier,
- Données.

Les données sont gérées de manière transactionnelle.

Cet aspect transactionnel est pris en charge par les EJB.




== Tester son code

=== Définition

Code qui exécute un autre code pour valider son comportement et/ou son état.

Utilité : validation automatique, détection des régressions, documentation, indication de performance.

http://www.vogella.com/tutorials/JUnit/article.html[Introduction aux tests].

=== Différentes catégories de test

- Tests unitaires : valide une partie très spécifique de l'application, en général une classe ou une méthode. On simule parfois l'environnement du code à tester (_mock_).
- Tests d'intégration : on valide le comportement de l'application dans son ensemble. On _déploie_ l'application dans un environnement conforme à la production et on teste par les _bouts_.
- Tests de performance : s'assurer des bonnes performances de l'application (_throughput_, _req/s_, ...).

On distingue deux autres catégories : tests d'_état_ et tests _comportementaux_.

=== Outils pour les tests

JUnit

TestNG

=== JUnit

junit.org

Dépôt https://github.com/junit-team/junit[Git Hub].

=== Exemple

[source,language=java]
----
public class MyTests {
    @Test
    public void multiplicationOfZeroIntegersShouldReturnZero() {
        MyClass tester = new MyClass(); // MyClass is tested

        // assert statements
        assertEquals("10 x 0 must be 0", 0, tester.multiply(10, 0));
        assertEquals("0 x 10 must be 0", 0, tester.multiply(0, 10));
        assertEquals("0 x 0 must be 0", 0, tester.multiply(0, 0));
    }
}
----

=== Conventions

Les classes de test pour un projet _maven_ se trouvent dans `src/test/java`. 
Les resources de test dans `src/test/resources`.

Il est courant d'ajouter le suffixe `Test` aux noms des classes de tests. 
Maven utilise cette convention pour exécuter automatiquement les tests se trouvant dans le bon répertoire.

Pour un projet maven, c'est le plugin `surefire` qui est en charge des tests (dans la phase _test_).

=== JUnit 4

Un ensemble d'annotations (package `org.junit`) est utilisé pour configurer une classe de test :

[cols="2*"]
|===
|Annotation
|Description

|`@Test`
|Identifie une méthode de test

|`@Before`, `@After`
|Méthode exécutée avant et après chaque test

|`@BeforeClass`, `@AfterClass`
|Méthode exécutée avant et après l'initialisation de la classe de tests. Doivent être _statique_.

|`@Ignore`
|Ignore un test

|`@Test(expected=SQLException.class)`
|Le test échoue si l'exception n'est pas levée

|`@Test(timeouot=100)`
|Le test échoue s'il ne termine pas en moins de 100ms.
|===

=== Assertions

Pour valider un test, on utilise les assertions de JUnit. Une assertion non validée dans un test positionne le test en échec.

Les assertions de JUnit sont des méthodes statiques de la classe `org.junit.Assert`.

[cols="2*"]
|===
|Méthode
|Description

|`fail(message)`
|Fait échouer le test

|`assertTrue(message, condition)`
|Vérifie que `condition` est vrai

|`assertFalse(...)`
|Vérifie que la condition est fausse

|`assertEquals(message, expected, actual)`
|Vérifie que `actual` est égal à `expected`
|===

`assertSame()`, `assertNotSame()`, `assertNull()`, `assertNotNull()`...

=== Utilisation avec Maven

Le framework JUnit est disponible sur Maven Central : 

[source]
----
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.12</version>
</dependency>
----

=== Exemple

Voici un http://www.vogella.com/tutorials/JUnit/article.html#exercise-using-junit[exemple] de mise en place de test unitaire.

=== Mocking

Parfois, il n'est pas possible d'isoler complètement une classe du reste de l'application (tout est lié).

On a alors recours à des outils de _mock_ qui permettent de remplacer les dépendances du code à tester
par des _bouchons_ simulant l'environnement du test (voir le framework http://site.mockito.org/[Mockito]).

=== Tests d'intégration

Ceux-ci sont les plus difficiles à mettre en place car il faut _déployer_ 
l'application dans un environnement _équivalent_ à celui de production (base de donnée, configuration, clustering, ...).

=== Arquillian

_Arquillian_ (http://arquillian.org/invasion/[site]) est un outil qui facilite la mise en place des tests d'intégration :

- Gère le lancement et l'arrêt d'un AS complet.
- Produit une archive contenant le code à tester à la volée.
- Déploie l'archive dans le conteneur de test.
- Exécute les tests d'intégration.
- Produit un rapport d'exécution.

S'intègre à `JUnit` et `TestNG`.

Avantanges : on n'a plus besoin de mocker les dépendances, tout est en place !

Inconvénients : lent puisque qu'on bootstrappe tout l'environnement de l'application.

=== Exemple

Voici un http://arquillian.org/guides/testing_java_persistence/[guide] de mise en place de test d'intégration avec 
Arquillian. On lance un Wildfly embarqué pour être 'iso-prod'.

Voir ce https://github.com/ltearno/BibliothequeAudio[projet] pour un exemple concret de mise en place.


=== Tests de performance

S'assurer des bonnes performances de l'application :

- nombre de requêtes par seconde,
- latence,
- capacité de traitement,...

Exemple d'outil : gatling.io[Gatling].


=== Couverture de code

En général on veut s'assurer que l'ensemble des tests (unitaires et intégration) couvrent l'ensemble du code applicatif.

Exemple : mettre en place http://site.mockito.org/[Mockito].




== CDI

Contextual Dependency Injection

Pour fonctionner un composant a besoin d'autres composants, ceux sont ses _dépendances_.

Les composants ne sont plus responsables de récupérer ces dépendances (eg. instances, services statiques, etc...) car c'est l'outil de _gestion des dépendances_ qui s'en charge pour eux.

`Weld` est l'implémentation de référence de la norme CDI, réalisé par _RedHat_.

Java EE 6, CDI 1.0, Weld 1.1
Java EE 7, CDI 1.2, Weld 2.4
JAVA EE 8, CDI 2.0, Weld 3.0

Pour JBoss, la dépendance Maven est la suivante :

[source,language=java]
----
<groupId>javax.enterprise</groupId>
	<artifactId>cdi-api</artifactId>
	<!-- Use version 2.0 for Weld 3 -->
	<version>1.2</version>
	<scope>provided</scope>
</dependency>
----

Doc : https://docs.jboss.org/weld/reference/1.0.0/en-US/html/beanscdi.html

===

Beans sans constructeur par défaut sont toujours des bean si le constructeur est annoté avec `@Inject`

Annotation `@Inject` : applicable à un constructeur, méthode ou attribut pour déclencher l'injection 
de dépendance et indiquer à CDI d'utiliser ce constructeur pour créer les instances de ce bean.

Le conteneur CDI choisit l'objet à injecter en fonction du type du point d'injection et ne prend pas 
en compte le nom du champ, de la méthode ou du paramètre.


=== Définition du bean

- classe qui contient de la logique applicative,
- appelé directement depuis du code Java, ou bien depuis des expressions EL,
- a accès aux ressources transactionnelles,
- les dépendances entre beans sont gérées par le conteneur d'application,
- la plupart des beans sont _stateful_ et _contextuels_,
- son cycle de vie est géré par le conteneur.

Important : *contextuel* et *cycle de vie géré par l'AS*.

=== Définition

Plus formellement :

A bean comprises the following attributes:

- A (nonempty) set of bean types
- A (nonempty) set of qualifiers
- A scope
- Optionally, a bean EL name
- A set of interceptor bindings
- A bean implementation

=== Types du bean

[source,language=java]
----
public class BookShop 
      extends Business
      implements Shop<Book>
{
   ...
}
----

Cette classe a quatre types au sens CDI : `BookShop`, `Business`, `Shop<Book>` et `Object`.