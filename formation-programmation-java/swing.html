<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="author" content="Arnaud Tournier - @ltearno - LTE Consulting - 2017 - Toulouse"><title>Programmation Java UI - Swing</title><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport"><link href="reveal.js/css/reveal.css" rel="stylesheet"><link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme"><link href="reveal.js/lib/css/zenburn.css" rel="stylesheet"><script>document.write( '<link rel="stylesheet" href="reveal.js/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );</script></head><body><div class="reveal"><div class="slides"><section><h1>Programmation Java UI - Swing</h1><p><small>Arnaud Tournier - @ltearno - LTE Consulting - 2017 - Toulouse</small></p></section><section id="_arnaud_tournier"><h2>Arnaud Tournier</h2><div class="paragraph"><p>Email: <a href="mailto:ltearno@gmail.com">ltearno@gmail.com</a></p></div>
<div class="paragraph"><p>Twitter: <a href="https://twitter.com/ltearno">@ltearno</a></p></div>
<div class="paragraph"><p>Web: <a href="http://www.lteconsulting.fr">www.lteconsulting.fr</a></p></div>
<div class="paragraph"><p><strong>LTE Consulting</strong> société de Développement, Conseil et Formation.</p></div>
<div class="paragraph"><p>Speaker à Java One, Devoxx, GDG, JUG, GWTCon&#8230;&#8203;</p></div></section>
<section><section id="_swing"><h2>Swing</h2><div class="paragraph"><p>Partie de la JRE qui permet de programmer des interfaces graphiques.</p></div><div class="paragraph"><p>Fonctionne sur tous les OS supportant la JVM.</p></div><div class="paragraph"><p>Successeur d&#8217;AWT avec lequel il est compatible.</p></div></section><section id="_principe"><h2>Principe</h2><div class="paragraph"><p>L&#8217;interface graphique est découpée en parties <em>élémentaires</em> et en panneaux.</p></div>
<div class="paragraph"><p>L&#8217;application est un assemblage de ces éléments.</p></div>
<div class="paragraph"><p>Il y a des <em>conteneurs</em> et des <em>composants graphiques</em>.</p></div>
<div class="paragraph"><p>Il y a toujours un conteneur de premier niveau qui représente la fenêtre de l&#8217;application.</p></div></section><section id="_conteneur_de_premier_niveau"><h2>Conteneur de premier niveau</h2><div class="ulist"><ul><li><p><code>JWindow</code> : une fenêtre minimale</p></li><li><p><code>JFrame</code> : une fenêtre standard</p></li><li><p><code>JApplet</code> : oubliez ça ne marche plus !</p></li></ul></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java">public static void main( String[] args )
{
    JFrame fenetre = new JFrame();
    fenetre.setBounds( 0, 0, 300, 300 );
    fenetre.setTitle( "Le titre" );

    fenetre.setVisible( true );
}</code></pre></div></div></section><section id="_fermeture_du_programme"><h2>Fermeture du programme</h2><div class="paragraph"><p>Par défaut, fermer la fenêtre principale ne déclenche pas l&#8217;arrêt du programme.</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java">fenetre.setDefaultCloseOperation( WindowConstants.EXIT_ON_CLOSE );</code></pre></div></div>
<div class="paragraph"><p>Il existe aussi <code>DO_NOTHING_ON_CLOSE</code> (par défaut), <code>HIDE_ON_CLOSE et `DISPOSE_ON_CLOSE</code>.</p></div></section><section id="_composition_d_une_fenêtre"><h2>Composition d&#8217;une fenêtre</h2><div class="paragraph"><p>Une fenêtre est composée du plusieurs <em>calques</em> dont un nous interresse particulièrement : le <code>ContentPanel</code>.</p></div>
<div class="paragraph"><p>Ce panneau permet d&#8217;ajouter d&#8217;autres composants graphiques dans la fenêtre.</p></div></section><section id="_ajout_de_composants_dans_une_fenêtre"><h2>Ajout de composants dans une fenêtre</h2><div class="paragraph"><p>Il est rare d&#8217;ajouter directement des composants dans une fenêtre.
En général les composants d&#8217;une application sont organisés en arborescence.</p></div>
<div class="paragraph"><p>Le conteneur de composants graphique standard est la classe <code>JPanel</code>.</p></div>
<div class="paragraph"><p>Ici nous ajoutons trois boutons dans la fenêtre. Mais en effet, ces trois boutons sont ajoutés dans un <code>JPanel</code>
qui lui-même est inséré dans la fenêtre.</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java">public static void main( String[] args )
{
    JFrame fenetre = new JFrame();
    fenetre.setBounds( 0, 0, 300, 300 );
    fenetre.setTitle( "Le titre" );

    fenetre.setDefaultCloseOperation( WindowConstants.EXIT_ON_CLOSE );

    JButton boutonRouge = new JButton( "Pilule rouge" );
    JButton boutonBleu = new JButton( "Pilule bleue" );

    JPanel buttonsPanel = new JPanel();
    buttonsPanel.add( boutonRouge );
    buttonsPanel.add( boutonBleu );

    fenetre.getContentPane().add( buttonsPanel );

    fenetre.setVisible( true );
}</code></pre></div></div></section><section id="_gestion_des_événements"><h2>Gestion des événements</h2><div class="paragraph"><p>Quand l&#8217;utilisateur provoque un événement dans l&#8217;interface graphique, Swing se doit de prévenir
votre programme. Ceci s&#8217;appelle la gestion d&#8217;événements.</p></div>
<div class="paragraph"><p>Le principe est de fournir au composant graphique un <em>écouteur</em> (un object implémentant une interface <code>Listener</code>).
Quand un événement se produit, Swing appelle la méthode correspondante sur l&#8217;objet enregistré comme écouteur.</p></div>
<div class="paragraph"><p>Un objet écouteur doit implémenter l&#8217;interface correspondant aux événements qu&#8217;il écoute.
Par exemple <code>MouseMotionListener</code> pour écouter les événements de la souris.</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java">public interface MouseListener extends EventListener {
    /**
     * Invoked when the mouse button has been clicked (pressed
     * and released) on a component.
     */
    public void mouseClicked(MouseEvent e);

    /**
     * Invoked when a mouse button has been pressed on a component.
     */
    public void mousePressed(MouseEvent e);

    ...
}</code></pre></div></div></section><section id="_la_classe_code_event_code"><h2>La classe <code>Event</code></h2><div class="paragraph"><p>Les classes <code>ComponentEvent</code>, <code>InputEvent</code>, <code>MouseEvent</code> portent un information au sujet de l&#8217;événement :</p></div>
<div class="ulist"><ul><li><p>le bouton actif de la souris,</p></li><li><p>la touche SHIFT est-elle appuyée ?</p></li><li><p>quelle touche a été frappée ?</p></li></ul></div>
<div class="paragraph"><p>&#8230;&#8203;</p></div></section><section id="_les_boutons_et_actionlistener"><h2>Les boutons et ActionListener</h2><div class="paragraph"><p>Un mécanisme similaire est en place pour les déclenchements des boutons.</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java">JFrame fenetre = new JFrame();

// ...

JButton boutonRouge = new JButton( "Pilule rouge" );
boutonRouge.setActionCommand( "ROUGE" );

JButton boutonBleu = new JButton( "Pilule bleue" );
boutonBleu.setActionCommand( "BLEU" );

JPanel buttonsPanel = new JPanel();
buttonsPanel.add( boutonRouge );
buttonsPanel.add( boutonBleu );

ActionListener listener = new ActionListener()
{
    @Override
    public void actionPerformed( ActionEvent event )
    {
        String action = event.getActionCommand();
        switch( action )
        {
            case "ROUGE":
                System.out.println( "Bouton ROUGE cliqué" );
                break;

            case "BLEU":
                System.out.println( "Bouton BLEU cliqué" );
                break;

            default:
                System.out.println( "Bouton INCONNU !" );
                break;
        }
    }
};

boutonRouge.addActionListener( listener );

fenetre.getContentPane().add( buttonsPanel );

fenetre.setVisible( true );</code></pre></div></div></section><section id="_les_conteneurs"><h2>Les conteneurs</h2><div class="paragraph"><p>Contiennent d&#8217;autres composants. Permettent l&#8217;assemblage.</p></div>
<div class="paragraph"><p><code>JContainer</code></p></div></section><section id="_les_composants_graphiques"><h2>Les composants graphiques</h2><div class="paragraph"><p>Ne contient pas d&#8217;autre composant. Utilisé pour afficher de l&#8217;information ou permettre la saisie.</p></div>
<div class="paragraph"><p><code>JComponent</code></p></div></section></section></div></div><script src="reveal.js/lib/js/head.min.js"></script><script src="reveal.js/js/reveal.js"></script><script>// See https://github.com/hakimel/reveal.js#configuration for a full list of configuration options
Reveal.initialize({
  // Display controls in the bottom right corner
  controls: true,
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: true,
  // Push each slide change to the browser history
  history: true,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Vertical centering of slides
  center: true,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Enable slide navigation via mouse wheel
  mouseWheel: true,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  previewLinks: false,
  // Theme (e.g., beige, black, league, night, serif, simple, sky, solarized, white)
  // NOTE setting the theme in the config no longer works in reveal.js 3.x
  //theme: Reveal.getQueryHash().theme || 'white',
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: Reveal.getQueryHash().transition || 'slide',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'zoom',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 1600,
  height: 1200,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.5,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
      { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
      { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
  ]
});</script></body></html>