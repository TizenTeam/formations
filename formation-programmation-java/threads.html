<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="author" content="Arnaud Tournier"><title>Les threads</title><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport"><link href="reveal.js/css/reveal.css" rel="stylesheet"><link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme"><link href="reveal.js/lib/css/zenburn.css" rel="stylesheet"><script>document.write( '<link rel="stylesheet" href="reveal.js/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );</script></head><body><div class="reveal"><div class="slides"><section><h1>Les threads</h1><p><small>Arnaud Tournier</small></p></section><section><section id="_les_threads"><h2>Les threads</h2></section><section id="_définition"><h2>Définition</h2><div class="paragraph"><p>Un thread est un fil d&#8217;exécution.</p></div>
<div class="paragraph"><p>Au sein d&#8217;un thread, l&#8217;exécution des instructions se fait en séquence (les unes après les autres).</p></div>
<div class="paragraph"><p>Une instruction est exécutée après que la précédente soit terminée.</p></div>
<div class="paragraph"><p>Concrètement, un thread possède principalement un pointeur d&#8217;instruction (IP) et une pile (Stack).</p></div></section><section id="_organisation"><h2>Organisation</h2><div class="paragraph"><p>Un programme en cours d&#8217;exécution s&#8217;appelle un <strong>processus</strong>. Au lancement d&#8217;un processus, le <strong>thread principal</strong> est créé, c&#8217;est celui qui exécute la méthode <strong>main()</strong> de l&#8217;application.</p></div>
<div class="paragraph"><p>Un programme peut demander au système d&#8217;exploitation de créer plusieurs <strong>threads</strong>. Plusieurs threads s&#8217;exécutent ainsi au sein du <em>même</em> processus.</p></div>
<div class="paragraph"><p>Cela permet d&#8217;effectuer <strong>plusieurs calculs en parallèle</strong> (en même temps).</p></div></section><section id="_gestion_mémoire"><h2>Gestion mémoire</h2><div class="paragraph"><p>Dans un processus, l&#8217;ensemble de l'<strong>espace mémoire est commun</strong> à toutes les threads.</p></div>
<div class="paragraph"><p>Mais chaque thread possède sa propre <strong>pile d&#8217;exécution</strong>.</p></div></section><section id="_ordonnancement"><h2>Ordonnancement</h2><div class="paragraph"><p>L&#8217;ordinateur ne possédant qu&#8217;un <strong>nombre fini de processeurs</strong>, seul un nombre limité de threads peut s&#8217;exécuter de façon réellement parallèle.</p></div>
<div class="paragraph"><p>Le système d&#8217;exploitation simule la simultanéité de l&#8217;exécution des threads grâce à des algorithmes de <strong>scheduling</strong>, c&#8217;est le multi-tâche.</p></div></section><section id="_accès_au_thread_courant"><h2>Accès au Thread courant</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java">Thread threadCourant = Thread.currentThread();
long id = threadCourant.getId();
String nom = threadCourant.getName();</code></pre></div></div></section><section id="_création_d_un_thread"><h2>Création d&#8217;un thread</h2><div class="paragraph"><p>En Java, on peut demander la création et le lancement d&#8217;un nouveau thread, qui exécutera le code demandé. Deux possibilités:</p></div>
<div class="ulist"><ul><li><p>créer une classe héritant de la classe <code>Thread</code></p></li><li><p>instancier une implémentation de l&#8217;interface <code>Runnable</code> et la passer au constructeur de la classe <code>Thread</code>.</p></li></ul></div></section><section id="_création_en_héritant_de_code_thread_code"><h2>Création en héritant de <code>Thread</code></h2><div class="paragraph"><p>On hérite de <code>Thread</code> et on implémente la méthode principale <code>run()</code> :</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java">public class TestThread extends Thread {
	public TestThread(String name){
		super(name);
	}

	// méthode principale du thread
	public void run(){
		for(int i = 0; i &lt; 10; i++)
		{
			System.out.println(getName());

			// attente de 50 millisencondes
			sleep( 50 ); // il faut gérer InterruptedException
		}
	}
}</code></pre></div></div></section><section id="_lancer_les_threads"><h2>Lancer les threads</h2><div class="paragraph"><p>On crée autant d&#8217;objets de la sous-classe de <code>Thread</code> que de threads à initialiser et exécuter.</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java">public class Test {
	public static void main(String[] args) {
		TestThread t = new TestThread("A");
		TestThread t2 = new TestThread("  B");

		t.start();
		t2.start();
	}
}</code></pre></div></div></section><section id="_exécution_des_threads"><h2>Exécution des threads</h2><div class="paragraph"><p>L&#8217;ordre d&#8217;exécution semble (<em>et est</em>) aléatoire:</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code>A
  B
  B
A
  B
A
A
  B</code></pre></div></div></section><section id="_bilan"><h2>Bilan</h2><div class="paragraph"><p>L&#8217;exécution des threads est régulée par le système d&#8217;exploitation.</p></div>
<div class="paragraph"><p>Il n&#8217;est pas possible de prédire l&#8217;ordre d&#8217;exécution.</p></div>
<div class="paragraph"><p>Donc nos programmes ne doivent pas faire d&#8217;hypothèses sur cet ordre.</p></div></section><section id="_etats_des_threads"><h2>Etats des threads</h2><div class="ulist"><ul><li><p><code>NEW</code> : tout juste créé.</p></li><li><p><code>RUNNABLE</code> : lorsqu&#8217;on invoque la méthode start(), le thread est prêt à travailler.</p></li><li><p><code>TERMINATED</code> : le thread a effectué toutes ses tâches, on dit aussi qu&#8217;il est <em>mort</em>. On ne peut plus le relancer par la méthode start().</p></li><li><p><code>TIMED_WAITING</code> : le thread est en pause (appel de la méthode <code>sleep()</code>, par exemple).</p></li><li><p><code>WAITING</code> : le thread est en attente indéfinie (opérations d&#8217;entrée/sortie).</p></li><li><p><code>BLOCKED</code> : lorsque l&#8217;ordonnanceur place un thread en sommeil pour en utiliser un autre, il lui impose cet état.</p></li></ul></div></section><section id="_fin_d_un_thread"><h2>Fin d&#8217;un thread</h2><div class="paragraph"><p>Un thread est terminé et s&#8217;arrête lorsque la méthode <code>run()</code> se termine.</p></div>
<div class="paragraph"><p>En effet, une nouvelle pile d&#8217;exécution contient à sa base la méthode <code>run()</code> de notre thread. Une fois celle-ci dépilée, le thread n&#8217;a plus rien à exécuter !</p></div></section></section>
<section><section id="_accès_concurrents_à_la_mémoire"><h2>Accès concurrents à la mémoire</h2></section><section id="_rappel_le_modèle_mémoire"><h2>Rappel : le modèle mémoire</h2><div class="paragraph"><p>Les threads partagent tous l&#8217;espace mémoire du processus dans lequel elles s&#8217;exécutent.</p></div>
<div class="paragraph"><p>Comme toutes s&#8217;exécutent en (pseudo-)même temps, il faut faire attention aux problèmes de concurrence!</p></div></section><section id="_création_d_un_thread_avec_l_interface_code_runnable_code"><h2>Création d&#8217;un thread avec l&#8217;interface <code>Runnable</code></h2><div class="paragraph"><p>On écrit une classe implémentant l&#8217;interface <code>Runnable</code>&#8230;&#8203;</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java">public class RunImpl implements Runnable
{
	private CompteEnBanque compte;

	// ...

	public void run()
	{
		for( int i = 0; i &lt; 5000; i++ )
		{
			compte.retrait( 1 );
		}
	}
}</code></pre></div></div></section><section id="_lancement_du_thread"><h2>Lancement du thread</h2><div class="paragraph"><p>Et on crée des instances de <code>Thread</code> en passant en paramètre du constructeur nos objets <code>Runnable</code> :</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java">CompteEnBanque compte = new CompteEnBanque( 5000 );

Thread t1 = new Thread( new RunImpl( compte ) );
Thread t2 = new Thread( new RunImpl( compte ) );

t1.start();
t2.start();

// on attend que les 2 threads soient terminées
t1.join();
t2.join();

System.out.println( "solde du compte (à priori -5000): " + compte.getSolde() );</code></pre></div></div></section><section id="_résultat"><h2>Résultat</h2><div class="paragraph"><p>Ce n&#8217;est pas le résultat attendu qui apparait !</p></div>
<div class="paragraph"><p>D&#8217;ailleurs il change à chaque exécution.</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code>-929</code></pre></div></div></section><section id="_pourquoi"><h2>Pourquoi ?</h2><div class="paragraph"><p>L&#8217;exécution des instructions d&#8217;un thread peut être interrompue à tout momment par le système d&#8217;exploitation pour <em>donner le processeur</em> à une autre thread.</p></div>
<div class="paragraph"><p>DEMONSTRATION</p></div></section></section>
<section><section id="_synchronisation"><h2>Synchronisation</h2><div class="paragraph"><p>La machine et le système d&#8217;exploitation fournissent les mécanismes nécessaires pour synchroniser les threads entre eux.</p></div><div class="paragraph"><p>Il est donc possible d&#8217;utiliser ces fonctionnalités dans un programme Java, grâce entre autres au mot-clé <code>synchronized</code>.</p></div></section><section id="_mot_clé_code_synchronized_code"><h2>Mot-clé <code>synchronized</code></h2><div class="paragraph"><p><code>synchronized</code> est applicable aux méthodes et on peut le préfixer à un bloc de code.</p></div>
<div class="paragraph"><p>Il est toujours (implicitement ou pas) lié à une clé de verrou, qui peut être n&#8217;importe quel objet.</p></div>
<div class="paragraph"><p>En toutes circonstances, un seul thread a accès a(ux) zone(s) protégé(es) par la clé de verrou.</p></div></section><section id="_clé_de_verrou"><h2>Clé de verrou</h2><div class="paragraph"><p>En fonction de l&#8217;élément sur lequel <code>synchronized</code> est appliqué, différents verrous sont utilisés :</p></div>
<div class="ulist"><ul><li><p>Si appliqué à une méthode, la clé de verrou est l&#8217;objet sur lequel est exécutée cette méthode.</p></li><li><p>Si la méthode est statique, le verrou est l&#8217;objet <code>Class</code> de la classe à laquelle elle appartient.</p></li><li><p>Si appliqué à un bloc, le verrou est précisé entre parenthèse après le mot-clé <code>synchronized</code>.</p></li></ul></div></section><section id="_synchronized_exemple"><h2>Synchronized, exemple</h2><div class="paragraph"><p>Dans notre exemple, il suffit de rajouter <code>synchronized</code> à la méthode <code>retrait(&#8230;&#8203;)</code></p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java">public class CompteEnBanque
{
	// ...

	// on ajoute 'synchronized' pour empêcher
	// plusieurs threads de rentrer dans la
	// méthode en "même" temps
	public synchronized void retrait( int montant )
	{
		solde -= montant;
	}
}</code></pre></div></div></section><section id="_vérouillage_d_un_bloc"><h2>Vérouillage d&#8217;un bloc</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java">synchronized(key) // key peut être n'importe quel objet
{
	// bloc synchronisé
}</code></pre></div></div>
<div class="paragraph"><p>Pour entrer dans le bloc, le thread doit acquérir le verrou associé à l&#8217;objet <code>key</code>.</p></div>
<div class="paragraph"><p>Si le verrou est déjà détenu par un autre thread, le thread est mis en attente.</p></div>
<div class="paragraph"><p>En sortant du bloc le thread libère le verrou. S&#8217;il y en a, un des threads en attente acquiert le verrou et entre dans le bloc.</p></div></section><section id="_deadlock_et_autres"><h2>Deadlock et autres</h2><div class="paragraph"><p>Attention la programmation multi-thread est très complexe.</p></div>
<div class="paragraph"><p>En général, cette complexité est masquée par les bibliothèques de haut-niveau.</p></div></section><section id="_classes_de_synchronisation"><h2>Classes de synchronisation</h2><div class="ulist"><ul><li><p>Compteurs atomiques: <strong>AtomicInteger</strong>, et autres types&#8230;&#8203;</p></li><li><p>Listes et structures <strong>thread-safe</strong>,</p></li><li><p>Objets de synchronisation de haut niveau (<strong>Mutex</strong>, <strong>Semaphore</strong>, &#8230;&#8203;)</p></li></ul></div></section><section id="_forkjoin_pool"><h2>ForkJoin Pool</h2><div class="paragraph"><p>Permet de traiter en parallèle un traitement facilement découpable en plusieurs sous-traitements.</p></div></section><section id="_plus_loin"><h2>Plus loin</h2><div class="paragraph"><p>L&#8217;idée est toujours de:</p></div>
<div class="ulist"><ul><li><p>maximiser l&#8217;utilisation des processeurs pour aller plus vite,</p></li><li><p>paralléliser les traitements (algorithmes et structures de données),</p></li><li><p>avec la plus grande facilité possible pour le développeur!</p></li></ul></div>
<div class="paragraph"><p><em>Lire "Systèmes d&#8217;exploitation" d&#8217;Andrew Tannenbaum.</em></p></div></section><section id="_"></section></section></div></div><script src="reveal.js/lib/js/head.min.js"></script><script src="reveal.js/js/reveal.js"></script><script>// See https://github.com/hakimel/reveal.js#configuration for a full list of configuration options
Reveal.initialize({
  // Display controls in the bottom right corner
  controls: true,
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: false,
  // Push each slide change to the browser history
  history: true,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Vertical centering of slides
  center: true,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  previewLinks: false,
  // Theme (e.g., beige, black, league, night, serif, simple, sky, solarized, white)
  // NOTE setting the theme in the config no longer works in reveal.js 3.x
  //theme: Reveal.getQueryHash().theme || 'beige',
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: Reveal.getQueryHash().transition || 'slide',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.5,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
      { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
      { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
  ]
});</script></body></html>